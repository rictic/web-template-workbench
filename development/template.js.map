{"version":3,"file":"template.js","sourceRoot":"","sources":["../src/template.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  boundAttributeSuffix,\n  getTemplateHtml,\n  marker,\n  markerMatch,\n  rawTextElement,\n} from './get-template-html.js';\nimport {RenderOptions} from './render.js';\nimport {templateFromLiterals} from './template-from-literals.js';\nimport {SVG_RESULT, TemplateResult} from './ttl.js';\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = () => d.createComment('');\n\nconst isArray = Array.isArray;\nexport const isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */\n);\n\nexport type Template = ManualTemplate | DomPartsTemplate;\nexport class ManualTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a manual template`);\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    const el = d.createElement('template');\n    el.innerHTML = html as unknown as string;\n    this.el = el;\n    walker.currentNode = this.el.content;\n\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          for (const name of (node as Element).getAttributeNames()) {\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              const value = (node as Element).getAttribute(name)!;\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              parts.push({\n                type: ATTRIBUTE_PART,\n                index: nodeIndex,\n                name: m[2],\n                strings: statics,\n                ctor: AttributePart,\n              });\n              (node as Element).removeAttribute(name);\n            } else if (name.startsWith(marker)) {\n              parts.push({\n                type: ELEMENT_PART,\n                index: nodeIndex,\n              });\n              (node as Element).removeAttribute(name);\n            }\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = window.trustedTypes\n              ? (window.trustedTypes.emptyScript as unknown as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized when cloning in IE (could simplify when\n            // IE is no longer supported)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n    // We could set walker.currentNode to another node here to prevent a memory\n    // leak, but every time we prepare a template, we immediately render it\n    // and re-use the walker in new TemplateInstance.clone().\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class ManualTemplateInstance {\n  template: Template;\n  parts: Array<Part | undefined> = [];\n\n  constructor(template: Template) {\n    this.template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this.template;\n    const startClone = performance.now();\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    performance.measure('clone template', {\n      start: startClone,\n      end: performance.now(),\n    });\n\n    const getPartsStart = performance.now();\n    // No get parts, so it takes zero times\n    performance.measure('get parts', {\n      start: getPartsStart,\n      end: getPartsStart,\n    });\n\n    // adoption happens as part of clone, so it also takes zero time\n    const adoptNodeStart = performance.now();\n    performance.measure('adopt', {\n      start: adoptNodeStart,\n      end: adoptNodeStart,\n    });\n\n    const partCreationStart = performance.now();\n    walker.currentNode = fragment;\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings\n          );\n        }\n        this.parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    // We need to set the currentNode away from the cloned tree so that we\n    // don't hold onto the tree even if the tree is detached and should be\n    // freed.\n    walker.currentNode = d;\n    performance.measure('create part wrappers', {\n      start: partCreationStart,\n      end: performance.now(),\n    });\n    return fragment;\n  }\n}\n\nexport class DomPartsTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  readonly parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a DOM Parts template`);\n    // Create template element\n    this.el = templateFromLiterals(strings, type, true);\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    const parts = this.el.content.getPartRoot().getParts();\n    let index = -1;\n    for (const part of parts) {\n      index++;\n      if (part instanceof NodePart) {\n        let attributePart:\n          | undefined\n          | (Omit<AttributeTemplatePart, 'strings'> & {strings: string[]});\n\n        for (let i = 0; i < part.metadata.length; i++) {\n          const code = part.metadata[i];\n          if (code === 'd') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n              attributePart = undefined;\n            }\n            this.parts.push({\n              type: ELEMENT_PART,\n              index,\n            });\n          } else if (code === 'attr') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n            }\n            let name = part.metadata[++i];\n            attributePart = {\n              type: ATTRIBUTE_PART,\n              index,\n              name,\n              ctor: AttributePart,\n              strings: [],\n            };\n          } else if (code[0] === '\"') {\n            attributePart!.strings.push(JSON.parse(code));\n          }\n        }\n        if (attributePart !== undefined) {\n          this.parts.push(attributePart);\n        }\n      } else if (part instanceof ChildNodePart) {\n        this.parts.push({\n          type: CHILD_PART,\n          index,\n        });\n      }\n    }\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class DomPartsTemplateInstance {\n  template: Template;\n  parts: Array<Part | undefined> = [];\n\n  constructor(template: DomPartsTemplate) {\n    this.template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this.template;\n    const cloneStart = performance.now();\n    const domPartRoot = content.getPartRoot().clone();\n    performance.measure('clone template', {\n      start: cloneStart,\n      end: performance.now(),\n    });\n\n    const getPartsStart = performance.now();\n    const domParts = domPartRoot.getParts();\n    performance.measure('get parts', {\n      start: getPartsStart,\n      end: performance.now(),\n    });\n    const adoptNodeStart = performance.now();\n    const fragment = document.adoptNode(domPartRoot.rootContainer);\n    performance.measure('adopt', {\n      start: adoptNodeStart,\n      end: performance.now(),\n    });\n\n    const partCreationStart = performance.now();\n    // See: https://github.com/tbondwilkinson/dom-parts/issues/6\n    // customElements.upgrade(fragment);\n    for (const part of parts) {\n      const domPart = domParts[part.index];\n      switch (part.type) {\n        case CHILD_PART:\n          this.parts.push(\n            new ChildPart(\n              (domPart as ChildNodePart).previousSibling,\n              (domPart as ChildNodePart).nextSibling as ChildNode,\n              this,\n              options\n            )\n          );\n          break;\n        case ATTRIBUTE_PART: {\n          this.parts.push(\n            new (part as AttributeTemplatePart).ctor(\n              (domPart as NodePart).node as HTMLElement,\n              (part as AttributeTemplatePart).name,\n              (part as AttributeTemplatePart).strings\n            )\n          );\n          break;\n        }\n      }\n    }\n    performance.measure('create part wrappers', {\n      start: partCreationStart,\n      end: performance.now(),\n    });\n    return fragment;\n  }\n}\n\nexport type TemplateInstance =\n  | DomPartsTemplateInstance\n  | ManualTemplateInstance;\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  readonly ctor: typeof AttributePart;\n  readonly strings: ReadonlyArray<string>;\n};\ntype ChildTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | ChildTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part = ChildPart | AttributePart;\n\nexport class ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions;\n  committedValue: unknown = '';\n  startNode: ChildNode;\n  endNode: ChildNode | null;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    _parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions\n  ) {\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this.options = options;\n  }\n}\n\nexport class AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  value: unknown | Array<unknown> = [];\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>\n  ) {\n    this.element = element;\n    this.name = name;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this.value = new Array(strings.length - 1).fill(new String());\n      this.strings = strings;\n    } else {\n      this.value = '';\n    }\n  }\n}\n"]}