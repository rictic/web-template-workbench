{"version":3,"file":"template-from-literals.js","sourceRoot":"","sources":["../src/template-from-literals.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {getTemplateHtml} from './get-template-html.js';\nimport {HTML_RESULT, ResultType} from './ttl.js';\n\n// Typings for the DOM Parts proposed standard as described by\n// https://github.com/tbondwilkinson/dom-parts and then implemented in\n// Chrome Canary v117.0.5890.0 with experimental web platform features\n// enabled.\ndeclare global {\n  interface PartRoot {\n    // In-order DOM array of parts.\n    getParts(): Part[];\n  }\n\n  class DocumentPart implements PartRoot {\n    constructor(rootContainer: Document | DocumentFragment);\n\n    getParts(): Part[];\n\n    clone(): DocumentPart;\n\n    readonly rootContainer: Document | DocumentFragment;\n  }\n\n  interface Document {\n    getPartRoot(): DocumentPart;\n  }\n\n  interface DocumentFragment {\n    getPartRoot(): DocumentPart;\n  }\n  interface Part {\n    readonly root?: PartRoot;\n    readonly metadata: string[];\n\n    disconnect(): void;\n  }\n  class NodePart implements Part {\n    readonly root?: PartRoot;\n    readonly metadata: string[];\n\n    readonly node: Node;\n\n    constructor(root: PartRoot, node: Node, init?: {metadata?: string[]});\n\n    disconnect(): void;\n  }\n  class ChildNodePart implements Part, PartRoot {\n    readonly root?: PartRoot;\n    readonly metadata: string[];\n\n    readonly previousSibling: ChildNode;\n    readonly nextSibling: ChildNode;\n\n    constructor(\n      root: PartRoot,\n      previousSibling: Node,\n      nextSibling: Node,\n      init?: {metadata?: string[]}\n    );\n\n    children(): Node[];\n\n    // All parts in this subtree.\n    getParts(): Part[];\n\n    // Replaces the children and parts in this range.\n    replaceChildren(...nodes: Array<Node | string>): void;\n\n    disconnect(): void;\n  }\n}\n\n/**\n * A crack at a simple ponyfill of\n * https://github.com/WICG/webcomponents/issues/1019 extended with an encoding\n * for attribute and element bindings in the returned NodePart's metadata.\n *\n * See the tests at ./test/template-from-literals_test.ts for more info.\n */\nexport function templateFromLiterals(\n  strings: TemplateStringsArray,\n  type: ResultType = HTML_RESULT,\n  useDomParts: boolean,\n): HTMLTemplateElement {\n  const [html, attrNames] = getTemplateHtml(strings, type);\n  let attrNameIdx = 0;\n  const template = document.createElement('template');\n  template.innerHTML = html as unknown as string;\n  const treeWalker = document.createTreeWalker(template.content);\n  let node: Node | null = treeWalker.nextNode();\n  let root;\n  if (useDomParts) {\n    root = template.content.getPartRoot();\n  }\n  while (node !== null) {\n    if (node.nodeType === Node.COMMENT_NODE) {\n      const comment = node as Comment;\n      if (/lit\\$\\d+/.test(comment.data)) {\n        if (useDomParts) {\n          const before = new Text();\n          const after = new Text();\n          comment.before(before);\n          comment.after(after);\n          new ChildNodePart(root!, before, after);\n          node = treeWalker.nextNode();\n          comment.remove();\n          continue;\n        } else {\n          comment.data = '?child-node-part?';\n          comment.after(new Comment('?/child-node-part?'));\n        }\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      const metadata: string[] = [];\n      const badAttributes: string[] = [];\n      for (const attr of element.attributes) {\n        if (/lit\\$\\d+\\$\\d+/.test(attr.name)) {\n          metadata.push('d');\n          badAttributes.push(attr.name);\n          continue;\n        }\n        const match = attr.name.match(/^(.*)\\$lit\\$$/);\n        if (match !== null) {\n          metadata.push('attr', attrNames[attrNameIdx]);\n          attrNameIdx++;\n          // const value = attr.value;\n          const regex = /(?:(lit\\$\\d+\\$))|(?:(.+?)(?:lit\\$\\d+\\$))|(.+)/g;\n          let endMatched = false;\n          for (const [_, bindingStart, lit, end] of attr.value.matchAll(\n            regex\n          )) {\n            if (bindingStart !== undefined) {\n              metadata.push('\"\"');\n            } else if (lit !== undefined) {\n              metadata.push(JSON.stringify(lit));\n            } else {\n              metadata.push(JSON.stringify(end));\n              endMatched = true;\n            }\n          }\n          if (endMatched === false) {\n            metadata.push('\"\"');\n          }\n          badAttributes.push(attr.name);\n        }\n      }\n      for (const attr of badAttributes) {\n        element.removeAttribute(attr);\n      }\n      if (metadata.length > 0) {\n        if (useDomParts) {\n          new NodePart(root!, element, {metadata});\n        } else {\n          element.before(new Comment(`?node-part ${metadata.join(' ')} ?`));\n        }\n      }\n    }\n    node = treeWalker.nextNode();\n  }\n  return template;\n}\n"]}