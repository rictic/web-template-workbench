<!DOCTYPE html>
<!--
Benchmark generated via the following invocation:
node generator/build/index.js -r lit-html,lit-html@tot=generator/scripts/package-versions-tot.json,lit-html@release=generator/scripts/package-versions-release.json -n template-heavy -o lit-html/template-heavy -u 10 -q -m render,update -g

Parameters:
  renderers: lit-html
  depth: 5
  width: 4
  attrPerNode: 4
  dynAttrPct: 0.5
  valPerDynAttr: 2
  dynNodePct: 0.5
  updateCount: 10
  updateNodePct: 1
  updateAttrPct: 1
  uniqueTemplates: true
  measure: render,update
-->
<html>
  <head> </head>
  <body>
    <script type="module">
      import { update } from "./heavy.js";
      import { html, render, nothing } from "https://unpkg.com/lit-html?module";

      const domParts = {
        name: "DOM Parts",
        options: { useDomParts: true },
        times: [],
      };
      const manual = {
        name: "Manual",
        options: { useDomParts: false },
        times: [],
      };
      // ensure that <template>s are created for both versions first,
      // because our DOM Parts template creation code is not optimized yet.
      update(document.createElement("div"), domParts.options);
      update(document.createElement("div"), manual.options);
      function drawConfig(config) {
        let timesReport = nothing;
        if (config.times.length > 0) {
          const average =
            config.times.reduce((a, b) => a + b, 0) / config.times.length;
          const stdDev = Math.sqrt(
            config.times.reduce((a, b) => a + (b - average) ** 2, 0) /
              config.times.length
          );
          timesReport = html`
            <span>
              Average time: ${average.toFixed(2)}ms &plusmn;
              ${stdDev.toFixed(2)}ms
            </span>
            <div style="display:none">
              ${config.times.map(
                (time) => html`<span>${time.toFixed(2)}ms</span>`
              )}
            </div>
          `;
        }
        function testAndUpdate() {
          test(config);
          main();
        }
        return html`
          <div>
            <button @click=${testAndUpdate}>${config.name}</button>
            ${timesReport}
          </div>
        `;
      }
      function drawComparison(left, right) {
        if (left.times.length === 0 || right.times.length === 0) {
          return nothing;
        }
        const leftAverage =
          left.times.reduce((a, b) => a + b, 0) / left.times.length;
        const rightAverage =
          right.times.reduce((a, b) => a + b, 0) / right.times.length;
        const diff = leftAverage - rightAverage;
        let faster, slower;
        if (diff < 0) {
          faster = left;
          slower = right;
        } else {
          faster = right;
          slower = left;
        }
        const timesFaster =
          1 + Math.abs(diff) / Math.min(leftAverage, rightAverage);
        return html`
          <div>
            <span>
              ${faster.name} is ${timesFaster.toFixed(2)}x faster than
              ${slower.name} over ${left.times.length} runs.
            </span>
          </div>
        `;
      }
      let numRuns = 100;
      let running = false;
      function main() {
        const gcAvailable = window.gc
          ? ""
          : `[window.gc is not availabe, run with --js-flags="--expose-gc"]`;
        render(
          html`
            <div>
              <div>${gcAvailable}</div>
              <button @click=${() => runMany(numRuns)}>
                Run ${numRuns} times
              </button>
              ${running ? html`Running...` : nothing}
              <div>
                <label
                  >Runs:
                  <input
                    type="number"
                    .value=${numRuns}
                    @input=${(e) => {
                      numRuns = e.target.value;
                      main();
                    }}
                  />
                </label>
              </div>
            </div>
            ${drawConfig(domParts)} ${drawConfig(manual)}
            ${drawComparison(domParts, manual)}
          `,
          document.body
        );
      }
      async function waitForPaint() {
        await new Promise((resolve) => requestAnimationFrame(resolve));
        await new Promise((resolve) => requestAnimationFrame(resolve));
      }
      async function runMany(count) {
        running = true;
        main();
        await waitForPaint();
        for (let i = 0; i < count; i++) {
          test(domParts);
          test(manual);
          // yield periodically to the event loop so we don't seem unresponsive
          await waitForPaint();
        }
        running = false;
        main();
      }
      main();
      function test(config) {
        if (window.gc) {
          window.gc();
          window.gc();
        }
        const container = document.createElement("div");
        document.body.appendChild(container);
        const startTime = performance.now();
        update(container, config.options);
        config.times.push(performance.now() - startTime);
        document.body.removeChild(container);
      }
    </script>
  </body>
</html>
