{"version":3,"file":"template.js","sources":["../../../src/template.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  boundAttributeSuffix,\n  getTemplateHtml,\n  marker,\n  markerMatch,\n  rawTextElement,\n} from './get-template-html.js';\nimport {RenderOptions} from './render.js';\nimport {templateFromLiterals} from './template-from-literals.js';\nimport {SVG_RESULT, TemplateResult} from './ttl.js';\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = () => d.createComment('');\n\nconst isArray = Array.isArray;\nexport const isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */\n);\n\nexport type Template = ManualTemplate | DomPartsTemplate;\nexport class ManualTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a manual template`);\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    const el = d.createElement('template');\n    el.innerHTML = html as unknown as string;\n    this.el = el;\n    walker.currentNode = this.el.content;\n\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          for (const name of (node as Element).getAttributeNames()) {\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              const value = (node as Element).getAttribute(name)!;\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              parts.push({\n                type: ATTRIBUTE_PART,\n                index: nodeIndex,\n                name: m[2],\n                strings: statics,\n                ctor: AttributePart,\n              });\n              (node as Element).removeAttribute(name);\n            } else if (name.startsWith(marker)) {\n              parts.push({\n                type: ELEMENT_PART,\n                index: nodeIndex,\n              });\n              (node as Element).removeAttribute(name);\n            }\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = window.trustedTypes\n              ? (window.trustedTypes.emptyScript as unknown as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized when cloning in IE (could simplify when\n            // IE is no longer supported)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n    // We could set walker.currentNode to another node here to prevent a memory\n    // leak, but every time we prepare a template, we immediately render it\n    // and re-use the walker in new TemplateInstance.clone().\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class ManualTemplateInstance {\n  template: Template;\n  parts: Array<Part | undefined> = [];\n\n  constructor(template: Template) {\n    this.template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this.template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings\n          );\n        }\n        this.parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    // We need to set the currentNode away from the cloned tree so that we\n    // don't hold onto the tree even if the tree is detached and should be\n    // freed.\n    walker.currentNode = d;\n    return fragment;\n  }\n}\n\nexport class DomPartsTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  readonly parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a DOM Parts template`);\n    // Create template element\n    this.el = templateFromLiterals(strings, type, true);\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    const parts = this.el.content.getPartRoot().getParts();\n    let index = -1;\n    for (const part of parts) {\n      index++;\n      if (part instanceof NodePart) {\n        let attributePart:\n          | undefined\n          | (Omit<AttributeTemplatePart, 'strings'> & {strings: string[]});\n\n        for (let i = 0; i < part.metadata.length; i++) {\n          const code = part.metadata[i];\n          if (code === 'd') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n              attributePart = undefined;\n            }\n            this.parts.push({\n              type: ELEMENT_PART,\n              index,\n            });\n          } else if (code === 'attr') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n            }\n            let name = part.metadata[++i];\n            attributePart = {\n              type: ATTRIBUTE_PART,\n              index,\n              name,\n              ctor: AttributePart,\n              strings: [],\n            };\n          } else if (code[0] === '\"') {\n            attributePart!.strings.push(JSON.parse(code));\n          }\n        }\n        if (attributePart !== undefined) {\n          this.parts.push(attributePart);\n        }\n      } else if (part instanceof ChildNodePart) {\n        this.parts.push({\n          type: CHILD_PART,\n          index,\n        });\n      }\n    }\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class DomPartsTemplateInstance {\n  template: Template;\n  parts: Array<Part | undefined> = [];\n\n  constructor(template: DomPartsTemplate) {\n    this.template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this.template;\n    const domPartRoot = content.getPartRoot().clone();\n    const domParts = domPartRoot.getParts();\n    const fragment = document.adoptNode(domPartRoot.rootContainer);\n    // See: https://github.com/tbondwilkinson/dom-parts/issues/6\n    // customElements.upgrade(fragment);\n    for (const part of parts) {\n      const domPart = domParts[part.index];\n      switch (part.type) {\n        case CHILD_PART:\n          this.parts.push(\n            new ChildPart(\n              (domPart as ChildNodePart).previousSibling,\n              (domPart as ChildNodePart).nextSibling as ChildNode,\n              this,\n              options\n            )\n          );\n          break;\n        case ATTRIBUTE_PART: {\n          this.parts.push(\n            new (part as AttributeTemplatePart).ctor(\n              (domPart as NodePart).node as HTMLElement,\n              (part as AttributeTemplatePart).name,\n              (part as AttributeTemplatePart).strings\n            )\n          );\n          break;\n        }\n      }\n    }\n    return fragment;\n  }\n}\n\nexport type TemplateInstance =\n  | DomPartsTemplateInstance\n  | ManualTemplateInstance;\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  readonly ctor: typeof AttributePart;\n  readonly strings: ReadonlyArray<string>;\n};\ntype ChildTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | ChildTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part = ChildPart | AttributePart;\n\nexport class ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions;\n  committedValue: unknown = '';\n  startNode: ChildNode;\n  endNode: ChildNode | null;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    _parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions\n  ) {\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this.options = options;\n  }\n}\n\nexport class AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  value: unknown | Array<unknown> = [];\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>\n  ) {\n    this.element = element;\n    this.name = name;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this.value = new Array(strings.length - 1).fill(new String());\n      this.strings = strings;\n    } else {\n      this.value = '';\n    }\n  }\n}\n"],"names":[],"mappings":"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"}