{"version":3,"file":"template.js","sources":["../../../src/template.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  boundAttributeSuffix,\n  getTemplateHtml,\n  marker,\n  markerMatch,\n  rawTextElement,\n} from './get-template-html.js';\nimport {DEV_MODE} from './modes.js';\nimport {RenderOptions} from './render.js';\nimport {templateFromLiterals} from './template-from-literals.js';\nimport {SVG_RESULT, TemplateResult} from './ttl.js';\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = () => d.createComment('');\n\nconst isArray = Array.isArray;\nexport const isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nexport const manualTemplateCache = new WeakMap<\n  TemplateStringsArray,\n  ManualTemplate\n>();\nexport const domPartsTemplateCache = new WeakMap<\n  TemplateStringsArray,\n  DomPartsTemplate\n>();\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */\n);\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // Rather than hold connection state on instances, Disconnectables recursively\n  // fetch the connection state from the RootPart they are connected in via\n  // getters up the Disconnectable tree via _$parent references. This pushes the\n  // cost of tracking the isConnected state to `AsyncDirectives`, and avoids\n  // needing to pass all Disconnectables (parts, template instances, and\n  // directives) their connection state each time it changes, which would be\n  // costly for trees that have no AsyncDirectives.\n  _$isConnected: boolean;\n}\n\nexport type Template = ManualTemplate | DomPartsTemplate;\nexport class ManualTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    console.log(`creating a manual template`);\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = ManualTemplate.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        if (DEV_MODE) {\n          const tag = (node as Element).localName;\n          // Warn if `textarea` includes an expression and throw if `template`\n          // does since these are not supported. We do this by checking\n          // innerHTML for anything that looks like a marker. This catches\n          // cases like bindings in textarea there markers turn into text nodes.\n          if (\n            /^(?:textarea|template)$/i!.test(tag) &&\n            (node as Element).innerHTML.includes(marker)\n          ) {\n            const m =\n              `Expressions are not supported inside \\`${tag}\\` ` +\n              `elements. See https://lit.dev/msg/expression-in-${tag} for more ` +\n              `information.`;\n            if (tag === 'template') {\n              throw new Error(m);\n            }\n          }\n        }\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          for (const name of (node as Element).getAttributeNames()) {\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              const value = (node as Element).getAttribute(name)!;\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              parts.push({\n                type: ATTRIBUTE_PART,\n                index: nodeIndex,\n                name: m[2],\n                strings: statics,\n                ctor: AttributePart,\n              });\n              (node as Element).removeAttribute(name);\n            } else if (name.startsWith(marker)) {\n              parts.push({\n                type: ELEMENT_PART,\n                index: nodeIndex,\n              });\n              (node as Element).removeAttribute(name);\n            }\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = window.trustedTypes\n              ? (window.trustedTypes.emptyScript as unknown as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized when cloning in IE (could simplify when\n            // IE is no longer supported)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n    // We could set walker.currentNode to another node here to prevent a memory\n    // leak, but every time we prepare a template, we immediately render it\n    // and re-use the walker in new TemplateInstance._clone().\n  }\n\n  // Overridden via `litHtmlPolyfillSupport` to provide platform support.\n  /** @nocollapse */\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = html as unknown as string;\n    return el;\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class ManualTemplateInstance {\n  _$template: Template;\n  _$parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template) {\n    this._$template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this as any,\n            options\n          );\n        }\n        this._$parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    // We need to set the currentNode away from the cloned tree so that we\n    // don't hold onto the tree even if the tree is detached and should be\n    // freed.\n    walker.currentNode = d;\n    return fragment;\n  }\n}\n\nexport class DomPartsTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  readonly parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a DOM Parts template`);\n    // Create template element\n    this.el = templateFromLiterals(strings, type, true);\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    const parts = this.el.content.getPartRoot().getParts();\n    let index = -1;\n    for (const part of parts) {\n      index++;\n      if (part instanceof NodePart) {\n        let attributePart:\n          | undefined\n          | (Omit<AttributeTemplatePart, 'strings'> & {strings: string[]});\n\n        for (let i = 0; i < part.metadata.length; i++) {\n          const code = part.metadata[i];\n          if (code === 'd') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n              attributePart = undefined;\n            }\n            this.parts.push({\n              type: ELEMENT_PART,\n              index,\n            });\n          } else if (code === 'attr') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n            }\n            let name = part.metadata[++i];\n            attributePart = {\n              type: ATTRIBUTE_PART,\n              index,\n              name,\n              ctor: AttributePart,\n              strings: [],\n            };\n          } else if (code[0] === '\"') {\n            attributePart!.strings.push(JSON.parse(code));\n          }\n        }\n        if (attributePart !== undefined) {\n          this.parts.push(attributePart);\n        }\n      } else if (part instanceof ChildNodePart) {\n        this.parts.push({\n          type: CHILD_PART,\n          index,\n        });\n      }\n    }\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class DomPartsTemplateInstance {\n  _$template: Template;\n  _$parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: DomPartsTemplate) {\n    this._$template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const domPartRoot = content.getPartRoot().clone();\n    const domParts = domPartRoot.getParts();\n    const fragment = document.adoptNode(domPartRoot.rootContainer);\n    // See: https://github.com/tbondwilkinson/dom-parts/issues/6\n    // customElements.upgrade(fragment);\n    for (const part of parts) {\n      const domPart = domParts[part.index];\n      switch (part.type) {\n        case CHILD_PART:\n          this._$parts.push(\n            new ChildPart(\n              (domPart as ChildNodePart).previousSibling,\n              (domPart as ChildNodePart).nextSibling as ChildNode,\n              this,\n              options\n            )\n          );\n          break;\n        case ATTRIBUTE_PART: {\n          this._$parts.push(\n            new (part as AttributeTemplatePart).ctor(\n              (domPart as NodePart).node as HTMLElement,\n              (part as AttributeTemplatePart).name,\n              (part as AttributeTemplatePart).strings,\n              this as any,\n              options\n            )\n          );\n          break;\n        }\n      }\n    }\n    return fragment;\n  }\n}\n\nexport type TemplateInstance =\n  | DomPartsTemplateInstance\n  | ManualTemplateInstance;\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  readonly ctor: typeof AttributePart;\n  readonly strings: ReadonlyArray<string>;\n};\ntype ChildTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | ChildTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part = ChildPart | AttributePart;\n\nexport class ChildPart implements Disconnectable {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions;\n  _$committedValue: unknown = '';\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /**\n   * Connection state for RootParts only (i.e. ChildPart without _$parent\n   * returned from top-level `render`). This field is unsed otherwise. The\n   * intention would clearer if we made `RootPart` a subclass of `ChildPart`\n   * with this field (and a different _$isConnected getter), but the subclass\n   * caused a perf regression, possibly due to making call sites polymorphic.\n   * @internal\n   */\n  __isConnected: boolean;\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    // ChildParts that are not at the root should always be created with a\n    // parent; only RootChildNode's won't, so they return the local isConnected\n    // state\n    return this._$parent?._$isConnected ?? this.__isConnected;\n  }\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$notifyConnectionChanged?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    _parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this.options = options;\n    // Note __isConnected is only ever accessed on RootParts (i.e. when there is\n    // no _$parent); the value on a non-root-part is \"don't care\", but checking\n    // for parent would be more code\n    this.__isConnected = options?.isConnected ?? true;\n  }\n}\n\n/**\n * A top-level `ChildPart` returned from `render` that manages the connected\n * state of `AsyncDirective`s created throughout the tree below it.\n */\nexport interface RootPart extends ChildPart {}\n\nexport class AttributePart implements Disconnectable {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = [];\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(new String());\n      this.strings = strings;\n    } else {\n      this._$committedValue = '';\n    }\n  }\n}\n"],"names":[],"mappings":"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"}