{"version":3,"file":"sanitizer.js","sources":["../../../src/sanitizer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ENABLE_EXTRA_SECURITY_HOOKS} from './modes.js';\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nexport const noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nexport const setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nexport const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nexport const createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\nexport const sanitizerActive = () => sanitizerFactoryInternal !== noopSanitizer;\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n"],"names":[],"mappings":"AAAA;;;;AAIG;AA4CH,MAAM,gBAAgB,GAAmB,CAAC,KAAc,KAAK,KAAK,CAAC;AAC5D,MAAM,aAAa,GAAqB,CAC7C,KAAW,EACX,KAAa,EACb,KAA+B,KAC5B,iBAAiB;AAEtB;AACa,MAAA,YAAY,GAAG,CAAC,YAA8B,KAAI;IAI7D,IAAI,wBAAwB,KAAK,aAAa,EAAE;QAC9C,MAAM,IAAI,KAAK,CACb,CAA2D,yDAAA,CAAA;AACzD,YAAA,CAAA,0DAAA,CAA4D,CAC/D,CAAC;AACH,KAAA;IACD,wBAAwB,GAAG,YAAY,CAAC;AAC1C,EAAE;AAEF;;AAEG;AACI,MAAM,6CAA6C,GAAG,MAAK;IAChE,wBAAwB,GAAG,aAAa,CAAC;AAC3C,EAAE;AAEW,MAAA,eAAe,GAAqB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,KAAI;IACpE,OAAO,wBAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACpD,EAAE;AAEW,MAAA,eAAe,GAAG,MAAM,wBAAwB,KAAK,cAAc;AAEhF,IAAI,wBAAwB,GAAqB,aAAa;;;;"}