{"version":3,"file":"template.js","sources":["../../src/template.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  boundAttributeSuffix,\n  getTemplateHtml,\n  marker,\n  markerMatch,\n  rawTextElement,\n} from './get-template-html.js';\nimport {RenderOptions} from './render.js';\nimport {templateFromLiterals} from './template-from-literals.js';\nimport {SVG_RESULT, TemplateResult} from './ttl.js';\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = () => d.createComment('');\n\nconst isArray = Array.isArray;\nexport const isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */\n);\n\nexport type Template = ManualTemplate | DomPartsTemplate;\nexport class ManualTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a manual template`);\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    const el = d.createElement('template');\n    el.innerHTML = html as unknown as string;\n    this.el = el;\n    walker.currentNode = this.el.content;\n\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          for (const name of (node as Element).getAttributeNames()) {\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              const value = (node as Element).getAttribute(name)!;\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              parts.push({\n                type: ATTRIBUTE_PART,\n                index: nodeIndex,\n                name: m[2],\n                strings: statics,\n                ctor: AttributePart,\n              });\n              (node as Element).removeAttribute(name);\n            } else if (name.startsWith(marker)) {\n              parts.push({\n                type: ELEMENT_PART,\n                index: nodeIndex,\n              });\n              (node as Element).removeAttribute(name);\n            }\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = window.trustedTypes\n              ? (window.trustedTypes.emptyScript as unknown as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized when cloning in IE (could simplify when\n            // IE is no longer supported)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n    // We could set walker.currentNode to another node here to prevent a memory\n    // leak, but every time we prepare a template, we immediately render it\n    // and re-use the walker in new TemplateInstance.clone().\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class ManualTemplateInstance {\n  template: Template;\n  parts: Array<Part | undefined> = [];\n\n  constructor(template: Template) {\n    this.template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this.template;\n    const startClone = performance.now();\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    performance.measure('clone template', {\n      start: startClone,\n      end: performance.now(),\n    });\n\n    const getPartsStart = performance.now();\n    // No get parts, so it takes zero times\n    performance.measure('get parts', {\n      start: getPartsStart,\n      end: getPartsStart,\n    });\n\n    // adoption happens as part of clone, so it also takes zero time\n    const adoptNodeStart = performance.now();\n    performance.measure('adopt', {\n      start: adoptNodeStart,\n      end: adoptNodeStart,\n    });\n\n    const partCreationStart = performance.now();\n    walker.currentNode = fragment;\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings\n          );\n        }\n        this.parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    // We need to set the currentNode away from the cloned tree so that we\n    // don't hold onto the tree even if the tree is detached and should be\n    // freed.\n    walker.currentNode = d;\n    performance.measure('create part wrappers', {\n      start: partCreationStart,\n      end: performance.now(),\n    });\n    return fragment;\n  }\n}\n\nexport class DomPartsTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  readonly parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a DOM Parts template`);\n    // Create template element\n    this.el = templateFromLiterals(strings, type, true);\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    const parts = this.el.content.getPartRoot().getParts();\n    let index = -1;\n    for (const part of parts) {\n      index++;\n      if (part instanceof NodePart) {\n        let attributePart:\n          | undefined\n          | (Omit<AttributeTemplatePart, 'strings'> & {strings: string[]});\n\n        for (let i = 0; i < part.metadata.length; i++) {\n          const code = part.metadata[i];\n          if (code === 'd') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n              attributePart = undefined;\n            }\n            this.parts.push({\n              type: ELEMENT_PART,\n              index,\n            });\n          } else if (code === 'attr') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n            }\n            let name = part.metadata[++i];\n            attributePart = {\n              type: ATTRIBUTE_PART,\n              index,\n              name,\n              ctor: AttributePart,\n              strings: [],\n            };\n          } else if (code[0] === '\"') {\n            attributePart!.strings.push(JSON.parse(code));\n          }\n        }\n        if (attributePart !== undefined) {\n          this.parts.push(attributePart);\n        }\n      } else if (part instanceof ChildNodePart) {\n        this.parts.push({\n          type: CHILD_PART,\n          index,\n        });\n      }\n    }\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class DomPartsTemplateInstance {\n  template: Template;\n  parts: Array<Part | undefined> = [];\n\n  constructor(template: DomPartsTemplate) {\n    this.template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this.template;\n    const cloneStart = performance.now();\n    const domPartRoot = content.getPartRoot().clone();\n    performance.measure('clone template', {\n      start: cloneStart,\n      end: performance.now(),\n    });\n\n    const getPartsStart = performance.now();\n    const domParts = domPartRoot.getParts();\n    performance.measure('get parts', {\n      start: getPartsStart,\n      end: performance.now(),\n    });\n    const adoptNodeStart = performance.now();\n    const fragment = document.adoptNode(domPartRoot.rootContainer);\n    performance.measure('adopt', {\n      start: adoptNodeStart,\n      end: performance.now(),\n    });\n\n    const partCreationStart = performance.now();\n    // See: https://github.com/tbondwilkinson/dom-parts/issues/6\n    // customElements.upgrade(fragment);\n    for (const part of parts) {\n      const domPart = domParts[part.index];\n      switch (part.type) {\n        case CHILD_PART:\n          this.parts.push(\n            new ChildPart(\n              (domPart as ChildNodePart).previousSibling,\n              (domPart as ChildNodePart).nextSibling as ChildNode,\n              this,\n              options\n            )\n          );\n          break;\n        case ATTRIBUTE_PART: {\n          this.parts.push(\n            new (part as AttributeTemplatePart).ctor(\n              (domPart as NodePart).node as HTMLElement,\n              (part as AttributeTemplatePart).name,\n              (part as AttributeTemplatePart).strings\n            )\n          );\n          break;\n        }\n      }\n    }\n    performance.measure('create part wrappers', {\n      start: partCreationStart,\n      end: performance.now(),\n    });\n    return fragment;\n  }\n}\n\nexport type TemplateInstance =\n  | DomPartsTemplateInstance\n  | ManualTemplateInstance;\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  readonly ctor: typeof AttributePart;\n  readonly strings: ReadonlyArray<string>;\n};\ntype ChildTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | ChildTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part = ChildPart | AttributePart;\n\nexport class ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions;\n  committedValue: unknown = '';\n  startNode: ChildNode;\n  endNode: ChildNode | null;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    _parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions\n  ) {\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this.options = options;\n  }\n}\n\nexport class AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  value: unknown | Array<unknown> = [];\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>\n  ) {\n    this.element = element;\n    this.name = name;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this.value = new Array(strings.length - 1).fill(new String());\n      this.strings = strings;\n    } else {\n      this.value = '';\n    }\n  }\n}\n"],"names":["d","document","createMarker","createComment","isArray","Array","isIterable","value","Symbol","iterator","walker","createTreeWalker","ManualTemplate","constructor","strings","_$litType$","type","_options","node","this","parts","console","log","nodeIndex","attrNameIndex","partCount","length","html","attrNames","getTemplateHtml","el","createElement","innerHTML","currentNode","content","SVG_RESULT","svgElement","firstChild","replaceWith","childNodes","nextNode","nodeType","hasAttributes","name","getAttributeNames","endsWith","boundAttributeSuffix","realName","statics","getAttribute","split","marker","m","exec","push","index","ctor","AttributePart","removeAttribute","startsWith","rawTextElement","test","tagName","textContent","lastIndex","window","trustedTypes","emptyScript","i","append","data","markerMatch","indexOf","ManualTemplateInstance","template","clone","options","startClone","performance","now","fragment","creationScope","importNode","measure","start","end","getPartsStart","adoptNodeStart","partCreationStart","partIndex","templatePart","undefined","part","ChildPart","nextSibling","DomPartsTemplate","templateFromLiterals","getPartRoot","getParts","NodePart","attributePart","metadata","code","JSON","parse","ChildNodePart","DomPartsTemplateInstance","cloneStart","domPartRoot","domParts","adoptNode","rootContainer","domPart","previousSibling","startNode","endNode","_parent","committedValue","element","fill","String"],"mappings":"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"}