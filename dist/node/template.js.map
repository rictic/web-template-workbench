{"version":3,"file":"template.js","sources":["../../src/template.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  boundAttributeSuffix,\n  getTemplateHtml,\n  marker,\n  markerMatch,\n  rawTextElement,\n} from './get-template-html.js';\nimport {DEV_MODE} from './modes.js';\nimport {RenderOptions} from './render.js';\nimport {templateFromLiterals} from './template-from-literals.js';\nimport {SVG_RESULT, TemplateResult} from './ttl.js';\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = () => d.createComment('');\n\nconst isArray = Array.isArray;\nexport const isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nexport const manualTemplateCache = new WeakMap<\n  TemplateStringsArray,\n  ManualTemplate\n>();\nexport const domPartsTemplateCache = new WeakMap<\n  TemplateStringsArray,\n  DomPartsTemplate\n>();\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */\n);\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // Rather than hold connection state on instances, Disconnectables recursively\n  // fetch the connection state from the RootPart they are connected in via\n  // getters up the Disconnectable tree via _$parent references. This pushes the\n  // cost of tracking the isConnected state to `AsyncDirectives`, and avoids\n  // needing to pass all Disconnectables (parts, template instances, and\n  // directives) their connection state each time it changes, which would be\n  // costly for trees that have no AsyncDirectives.\n  _$isConnected: boolean;\n}\n\nexport type Template = ManualTemplate | DomPartsTemplate;\nexport class ManualTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    console.log(`creating a manual template`);\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = ManualTemplate.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        if (DEV_MODE) {\n          const tag = (node as Element).localName;\n          // Warn if `textarea` includes an expression and throw if `template`\n          // does since these are not supported. We do this by checking\n          // innerHTML for anything that looks like a marker. This catches\n          // cases like bindings in textarea there markers turn into text nodes.\n          if (\n            /^(?:textarea|template)$/i!.test(tag) &&\n            (node as Element).innerHTML.includes(marker)\n          ) {\n            const m =\n              `Expressions are not supported inside \\`${tag}\\` ` +\n              `elements. See https://lit.dev/msg/expression-in-${tag} for more ` +\n              `information.`;\n            if (tag === 'template') {\n              throw new Error(m);\n            }\n          }\n        }\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          for (const name of (node as Element).getAttributeNames()) {\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              const value = (node as Element).getAttribute(name)!;\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              parts.push({\n                type: ATTRIBUTE_PART,\n                index: nodeIndex,\n                name: m[2],\n                strings: statics,\n                ctor: AttributePart,\n              });\n              (node as Element).removeAttribute(name);\n            } else if (name.startsWith(marker)) {\n              parts.push({\n                type: ELEMENT_PART,\n                index: nodeIndex,\n              });\n              (node as Element).removeAttribute(name);\n            }\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = window.trustedTypes\n              ? (window.trustedTypes.emptyScript as unknown as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized when cloning in IE (could simplify when\n            // IE is no longer supported)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n    // We could set walker.currentNode to another node here to prevent a memory\n    // leak, but every time we prepare a template, we immediately render it\n    // and re-use the walker in new TemplateInstance._clone().\n  }\n\n  // Overridden via `litHtmlPolyfillSupport` to provide platform support.\n  /** @nocollapse */\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = html as unknown as string;\n    return el;\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class ManualTemplateInstance {\n  _$template: Template;\n  _$parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template) {\n    this._$template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this as any,\n            options\n          );\n        }\n        this._$parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    // We need to set the currentNode away from the cloned tree so that we\n    // don't hold onto the tree even if the tree is detached and should be\n    // freed.\n    walker.currentNode = d;\n    return fragment;\n  }\n}\n\nexport class DomPartsTemplate {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  readonly parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    _options?: RenderOptions\n  ) {\n    console.log(`creating a DOM Parts template`);\n    // Create template element\n    this.el = templateFromLiterals(strings, type, true);\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    const parts = this.el.content.getPartRoot().getParts();\n    let index = -1;\n    for (const part of parts) {\n      index++;\n      if (part instanceof NodePart) {\n        let attributePart:\n          | undefined\n          | (Omit<AttributeTemplatePart, 'strings'> & {strings: string[]});\n\n        for (let i = 0; i < part.metadata.length; i++) {\n          const code = part.metadata[i];\n          if (code === 'd') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n              attributePart = undefined;\n            }\n            this.parts.push({\n              type: ELEMENT_PART,\n              index,\n            });\n          } else if (code === 'attr') {\n            if (attributePart !== undefined) {\n              this.parts.push(attributePart);\n            }\n            let name = part.metadata[++i];\n            attributePart = {\n              type: ATTRIBUTE_PART,\n              index,\n              name,\n              ctor: AttributePart,\n              strings: [],\n            };\n          } else if (code[0] === '\"') {\n            attributePart!.strings.push(JSON.parse(code));\n          }\n        }\n        if (attributePart !== undefined) {\n          this.parts.push(attributePart);\n        }\n      } else if (part instanceof ChildNodePart) {\n        this.parts.push({\n          type: CHILD_PART,\n          index,\n        });\n      }\n    }\n  }\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nexport class DomPartsTemplateInstance {\n  _$template: Template;\n  _$parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: DomPartsTemplate) {\n    this._$template = template;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const domPartRoot = content.getPartRoot().clone();\n    const domParts = domPartRoot.getParts();\n    const fragment = document.adoptNode(domPartRoot.rootContainer);\n    // See: https://github.com/tbondwilkinson/dom-parts/issues/6\n    // customElements.upgrade(fragment);\n    for (const part of parts) {\n      const domPart = domParts[part.index];\n      switch (part.type) {\n        case CHILD_PART:\n          this._$parts.push(\n            new ChildPart(\n              (domPart as ChildNodePart).previousSibling,\n              (domPart as ChildNodePart).nextSibling as ChildNode,\n              this,\n              options\n            )\n          );\n          break;\n        case ATTRIBUTE_PART: {\n          this._$parts.push(\n            new (part as AttributeTemplatePart).ctor(\n              (domPart as NodePart).node as HTMLElement,\n              (part as AttributeTemplatePart).name,\n              (part as AttributeTemplatePart).strings,\n              this as any,\n              options\n            )\n          );\n          break;\n        }\n      }\n    }\n    return fragment;\n  }\n}\n\nexport type TemplateInstance =\n  | DomPartsTemplateInstance\n  | ManualTemplateInstance;\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  readonly ctor: typeof AttributePart;\n  readonly strings: ReadonlyArray<string>;\n};\ntype ChildTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | ChildTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part = ChildPart | AttributePart;\n\nexport class ChildPart implements Disconnectable {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions;\n  _$committedValue: unknown = '';\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /**\n   * Connection state for RootParts only (i.e. ChildPart without _$parent\n   * returned from top-level `render`). This field is unsed otherwise. The\n   * intention would clearer if we made `RootPart` a subclass of `ChildPart`\n   * with this field (and a different _$isConnected getter), but the subclass\n   * caused a perf regression, possibly due to making call sites polymorphic.\n   * @internal\n   */\n  __isConnected: boolean;\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    // ChildParts that are not at the root should always be created with a\n    // parent; only RootChildNode's won't, so they return the local isConnected\n    // state\n    return this._$parent?._$isConnected ?? this.__isConnected;\n  }\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$notifyConnectionChanged?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    _parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this.options = options;\n    // Note __isConnected is only ever accessed on RootParts (i.e. when there is\n    // no _$parent); the value on a non-root-part is \"don't care\", but checking\n    // for parent would be more code\n    this.__isConnected = options?.isConnected ?? true;\n  }\n}\n\n/**\n * A top-level `ChildPart` returned from `render` that manages the connected\n * state of `AsyncDirective`s created throughout the tree below it.\n */\nexport interface RootPart extends ChildPart {}\n\nexport class AttributePart implements Disconnectable {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = [];\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(new String());\n      this.strings = strings;\n    } else {\n      this._$committedValue = '';\n    }\n  }\n}\n"],"names":["d","document","createMarker","createComment","isArray","Array","isIterable","value","Symbol","iterator","manualTemplateCache","WeakMap","domPartsTemplateCache","walker","createTreeWalker","ManualTemplate","constructor","strings","_$litType$","type","options","node","this","parts","console","log","nodeIndex","attrNameIndex","partCount","length","html","attrNames","getTemplateHtml","el","createElement","currentNode","content","SVG_RESULT","svgElement","firstChild","replaceWith","childNodes","nextNode","nodeType","hasAttributes","name","getAttributeNames","endsWith","boundAttributeSuffix","realName","statics","getAttribute","split","marker","m","exec","push","index","ctor","AttributePart","removeAttribute","startsWith","rawTextElement","test","tagName","textContent","lastIndex","window","trustedTypes","emptyScript","i","append","data","markerMatch","indexOf","static","_options","innerHTML","ManualTemplateInstance","template","_$parts","_$disconnectableChildren","undefined","_$template","_clone","fragment","creationScope","importNode","partIndex","templatePart","part","ChildPart","nextSibling","DomPartsTemplate","templateFromLiterals","getPartRoot","getParts","NodePart","attributePart","metadata","code","JSON","parse","ChildNodePart","DomPartsTemplateInstance","domPartRoot","clone","domParts","adoptNode","rootContainer","domPart","previousSibling","_$isConnected","_$parent","__isConnected","startNode","endNode","_parent","_$committedValue","_$startNode","_$endNode","isConnected","element","parent","fill","String"],"mappings":"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"}